        Шаблон проектирования MVC

        Роутинг, конфиги, навигация, маршрутизация

1. Создаем директорию "app" - здесь будет храниться основная часть приложения.
2. В этой папке создаем еще 3: "controllers","models","views".
3. В корне создаем папку "core", в этой папке будут все служебные классы которые будут относиться к нашему
фреймворку.
4. Создаем директорию "public" в этой папке будут лежать все файлы доступные напрямую извне.
5. Создаем файлик .htaccess в корне и такой же файл, но с другим контентом в папке "public".
Заполняем их данными.
6. Также в "public" создадим index.php, также там будут папки с картинками, css, js ...
7. В index.php объявляем константы путей к папкам.
8. В папке "core" создадим класс, который будет запускать наше приложение, например назовем его
"Application", namespace ему зададим core, в данном классе объявим статический метод run, который и
будет нам запускать приложение.
9. Реализуем автозагрузку классов.
10. Прописываем конфигурации и делаем их загрузку.
11. В папке "core" создаем новый класс Configurator, он будет загружать конфигурации. Сделаем в нем
приватное свойство data и конструктор, который будет принимать строку configname. Конфигуратор будет
работать по принципу: если есть пользовательский конфиг, то он будет загружать его, если нет,
то стандартный.
12. В папке app и в папке core сделаем директории с одинаковым именем config. Создадим сразу пользовательский
конфиг в папке app. Конфиг будет возвращать массив настроек, этот массив будет содержать элемент routes, в
котором будет массив всех наших маршрутов.
13. Возвращаемся в конфигуратор, объявляем 2 константы пути к конфигам: CONFIG_CORE_PATH и CONFIG_APP_PATH
14. Проверяем существование пользовательского конфига при помощи file_exists, если его нет, то подгружаем
конфиг из папки ядра приложения. Если есть, то при помощи include подключаем наш файл конфигурации и
возвращаем массив конфигов в нашу пустую data.
15. Перезапишем магический метод __get который нам будет возвращать нашу data,
в этот метод передадим параметр name, данный метод вернет нам data[name].
в котором будем указывать, что конкретно мы захотим вернуть (в нашем случае это будет routes).
16. Теперь в Application в методе run мы можем получать наши routes.
17. Создадим в папке сore папку router, в ней будет 2 сущности: Router, Route. Сейчас делаем простой
маршрутизатор. Обязательно для этих сущностей надо указать namespace.
18. Перейдем в Route, создадим там свойство url и params (имя контроллера и экшна).
19. Создадим конструктор, который получает оба параметра.
20. Создадим 2 свойства getControllerName, getActionName они будут возвращать $this->params["controller"],
и $this->params["action"].
21. Создадим также публичный метод match, который будет возвращать bool, будет проверять, подходит
нам текущий маршрут или нет.
22. Объявим в нем переменную $uri = $_SERVER["REQUEST_URI"].
У этой переменной уберем все до знака вопроса при помощи substr и strpos. И будем сравнивать окончательный
$uri и нашей свойство $url.
23. Наш конфигурационный файл router теперь будет из себя представлять массив экземпляров класса Route,
в который параметрами будем передавать $url и необходимые нам параметры.
24. Перейдем в класс Route. У него будет свойство routes, изначально пустой массив. Будет конструктор,
в который будем передавать массив роутов из нашего конфига.
26. Сделаем метод navigate(), пока-что пустой
25. Сделаем метод route(). В этом методе мы будем перебирать массив наших роутов, и при помощи метода
роута - матч, будем проверять каждый элемент, если произойдет совпадение, то будем формировать переменные
контроллер_нэйм и экшн_нэйм, далее эти переменные передадим в метод navigate. Если не будет найдено
ни одного совпадения, то мы создадим в папке Router класс исключения RouterException, который будет
наследоваться от Exception, его мы опишем позже.
26. В методе navigate() мы будем подключать файл контроллера и запускать там метод экшн.
Т.к. все классы у нас начинаются в заглавной большой буквы, то при помощи метода ucfirst, установим
название класса с большйо буквы.
Если файла или метода не будет, то ошибку также будем перехватывать через RouterException
27. В классе Application создаем роутер и у него вызываем метод route().

        Контроллеры и вью

1. Создадим в папке core папку base, в ней у нас будут храниться базовые Сontroller и View
2. В классе View создадим протектед св-во $data, паблик функцию render,
которая будет принимать какой-то массив $data, который по умолчанию будет пустым,
и создадим приватное свойство $path, это будет наше имя вью.
3. Создадим конструктор который будет принимать имя вью, путь в нашему файлу вью и потом передадим это
в наш $path.
4. В методе рендер объявим новую переменную $data, которая будет склеивать (array_merge) те данные,
которые мы будем передавать в кач-ве аргумента в методе рендер + ту дату, которая будет храниться в самом
св-ве класса.
5. После этого методом extract распакуем наш новый массив дата на переменные. После этого выполним
ob_start, далее include $this->path, пробросим нашу вьюшку и выполним ob_get_clean()
6. При помощи ctrl+o перегрузим метод __toString в нем сделаем return $this->render(), чтоб вернувшаяся
из контроллера вьюшка сразу попала в это и вывелась.
7. Кроме этого перегрузим метод __set, в нем будем делать $this->data["name"] = $value;. Т.е. будем
в нашу дату в поле нейм записывать значение value.
8. В папке views сделаем вьюшку main, запишем туда какой-нибудь html с переменной
9. Создадим в папке app/controllers, класс с названием Main. В нем создадим паблик метод actionIndex.
10. В это методе объявим новую переменную view в которую запишем экземпляр класса View, передадим туда
название view, это будет main, при помощи волшебного метода(__set) запишем в массив данных название переменной
которую мы хотим вывести, потом при помощи снова волшебного метода (__toString)
через return вернем нашу view.

11. Вью с шаблоном. В папке base сделаем новый класс TemplateView. Он будет наследоваться от View.
12. Перегружаем метод render и конструктор. В конструкторе пробрасываем кроме имени вью, еще и темплате.
Причем в парент конструктор у нас будет попадать templates/имя темплейта, а не вью. При этом мы создадим еще
приватное св-во view, которое в конструкторе будет равно новому экземпляру класса View,
с аргументом (имя вью).
13. Теперь в методе рендер в массив $data добавим ключ "content" со значением $this->view->render(),
в этот рендер аргументом поставим array_merge($data,$this->data);
14. После этого пишем parent::render($data);
15. Т.е. перед тем, как рендерить, мы в массив данных пробросили уже отрендеренную вьюшку. И в результате
будем выводить уже наш темплейт с вью вместе.
16. В папке Views создадим директорию templates в ней создадим php файл default, в нем сделаем хтмл
разметку, и в поле боди выведем переменную контент.
17. Теперь в контроллере создаем экземпляр класса TemplateView,
в кач-ве аргументов передаем default и main.

        Улучшение контроллера

1. В базовом абстрактном классе Controller, сделаем паблик метод execAction,
который будет принимать string $action, и возвращать return $this->$action,
т.е выполненять метод Action, который в него будет попадать.
2. Теперь контроллер у нас будет наследоваться от базового контроллера.
3. В Роутере мы убираем строку echo $ctrl->$action_name(),
а вместо нее напишем $ctrl->execAction($action_name);

4. Сделаем еще один базовый абстрактный класс, который назовем например RestController и
тоже будет наследоваться от контроллера.
5. В нем перегрузим метод execAction, только теперь он у нас будет возвращать
json_encode(parent::execAction($action));
6. Создадим еще один контроллер Api, который будет наследоваться от RestController.
7. В нем будет паблик метод actionApi, который будет возвращать массив каких-то данных;
8. В роут конфиге добавим еще один путь, в котором пропишем контроллер и экшн для нашего Api.
9. Теперь при необходимости получить просто json представление каких-либо данных мы можем использовать
контроллер который будет наследоваться от RestController, т.е. контроллеры нам могут выводить
информацию в том виде, в котором мы хотим ее получить, будь то хтмл или какой-другой вид.


